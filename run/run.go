package run

import (
	"strconv"
	"github.com/olekukonko/tablewriter"
	"bytes"
	"fmt"
	"io"
	"os"
	"os/exec"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/Songmu/prompter"

	"gopkg.in/mgo.v2/bson"

	"gopkg.in/mgo.v2"

	"github.com/user/numb/utils"
	"github.com/user/numb/database"
	"github.com/user/numb/versioning"
	pp "github.com/user/numb/prettyprint"
)

const (
	TRAIN RunMode = iota
	TEST
	QUEUE
)
type RunMode int

// Train runs a command in train mode.
func Train(cmdline string, runconfig map[string]interface{}, collection *mgo.Collection) {
	trainEnv := make(map[string]string)
	trainEnv["NUMB_MODE"] = "TRAIN"
	run(cmdline, trainEnv, runconfig, TRAIN, collection, "", nil)
}

// Test runs a command in train mode.
func Test(cmdline string, runconfig map[string]interface{}, collection *mgo.Collection, reader io.Reader) {
	testEnv := make(map[string]string)
	testEnv["NUMB_MODE"] = "TEST"
	if reader == nil {
		reader = os.Stdin
	}
	testAll, ok := runconfig["all"].(bool)
	if !testAll || !ok {
		run(cmdline, testEnv, runconfig, TEST, collection, "", reader)
	} else {
		totalTestCount := 0
		for {
			cnt := run(cmdline, testEnv, runconfig, TEST, collection, "", reader)
			totalTestCount += cnt
			if cnt == 0 {
				fmt.Println("Done testing in chunk")
				fmt.Printf("%d tests made in total\n", totalTestCount)
				break
			}
		}
	}
}

func runTrain(cmd *exec.Cmd, graphReader, paramReader, stateDictReader, codeReader *os.File, collection *mgo.Collection, queued bool) int {

	// retrieve compgraph & params
	var concreteGraph string
	var paramJSON string
	var nnCode string
	readDone := make(chan int)

	var readFrom = func(reader *os.File, payload *string, channel chan int) {
		buf := bytes.NewBuffer(nil)
		_, err := io.Copy(buf, reader)
		utils.Check(err)
		*payload = string(buf.Bytes())
		channel <- 0
	}
	go readFrom(graphReader, &concreteGraph, readDone) // receive comp graph
	go readFrom(paramReader, &paramJSON, readDone)     // receive parameters
	go readFrom(codeReader, &nnCode, readDone)         // receive nn code
	<-readDone
	<-readDone
	<-readDone // wait for both to be done

	// search in database for already-trained model
	// under queued mode, we do not check for dup
	if !queued {
		alreadyTrainedQuery := collection.Find(bson.M{"concrete": concreteGraph, "params": paramJSON})
		if cnt, _ := alreadyTrainedQuery.Count(); cnt != 0 {
			fmt.Println("This architecture has been trained with the same hyper-parameters previously")
			yes := prompter.YesNo("Are you sure you want to retrain it?", false)
			if !yes {
				fmt.Println("SHUTTING DOWN")
				cmd.Process.Signal(syscall.SIGINT)
				return 0
			}
		}
	}
	
	_, abstractGraph := utils.Concrete2Abstract(concreteGraph)

	// retrieve state dict
	currTime := time.Now()
	stateDictFile, err := os.Create(".nmb/" + strconv.FormatInt(currTime.UnixNano(), 10))
	utils.Check(err)
	io.Copy(stateDictFile, stateDictReader) // dump the statedict

	// save it in database
	var newEntry database.Schema
	newEntry.AbstractGraph = abstractGraph
	newEntry.ConcreteGraph = concreteGraph
	newEntry.Code = nnCode
	newEntry.Params = paramJSON
	newEntry.StateDictFilename = strconv.FormatInt(currTime.UnixNano(), 10)
	newEntry.Test = ""
	newEntry.Timestamp = currTime.UnixNano()
	newEntry.Versioning = ""

	utils.Check(cmd.Wait())

	// also, versioning is not possible under queued mode
	if !queued {
		// make commit on numb branch
		oid, err := versioning.FlashCommit(paramJSON)
		utils.Check(err)
		if oid != nil {
			newEntry.Versioning = oid.String()
		}
	}
	
	err = collection.Insert(&newEntry)
	utils.Check(err)
	return 1
}

// runTest returns the number of "tasks" executed
func runTest(cmd *exec.Cmd, graphReader, interactWriter, testResultReader *os.File, sigs chan int, collection *mgo.Collection, queued bool) int {
	// get comp graph first
	buf := bytes.NewBuffer(nil)
	_, err := io.Copy(buf, graphReader)
	utils.Check(err)
	concreteGraph := string(buf.Bytes())

	query := collection.Find(bson.M{"concrete": concreteGraph}).Sort("-timestamp")
	if cnt, _ := query.Count(); cnt == 0 {
		cmd.Process.Signal(syscall.SIGUSR2)
		fmt.Println("The model you are testing doesn't even exist")
		return 0
	}
	<-sigs // blocks until signal comes

	// retrieve result(s)
	results := make([]database.Schema, 0)
	utils.Check(query.All(&results))
	result := results[0]

	fmt.Println("Current architecture was generated by the following code:")
	fmt.Println(result.Code)
	fmt.Println()

	// start prompting user:
	fmt.Println("This model has been trained with following parameters.")
	fmt.Println("Simply hit enter to use the latest. Or input the number to specify.")
	fmt.Println()

	for idx, r := range results {
		fmt.Printf("%d:\n", idx)
		obj, err := utils.Str2Obj(r.Params)
		if r.Params != "" && err == nil {
			pp.TablePrint(obj, tablewriter.BgBlueColor).Render()
		} else {
			pp.DisplayHyperParamFailure()
		}
		obj, err = utils.Str2Obj(r.Test)
		if r.Test != "" && err == nil {
			pp.TablePrint(obj, tablewriter.BgYellowColor).Render()
		} else {
			pp.DisplayTestFailure()
		}
	}
	fmt.Println()

	// this function returns the index of the next untested model
	getNextUntested := func() int {
		for choice, result := range results {
			if result.Test == "" {
				return choice
			}
		}
		return -1 // all are tested!
	}

	var choice = 0
	if !queued {
		for {
			fmt.Print("Use parameter: ")
			fmt.Scanln(&choice)
			if choice >= 0 && choice < len(results) {
				break
			} else {
				fmt.Println("Invalid Index! Please try again.")
			}
		}
	} else { // smartly fetch next untest model
		choice = getNextUntested()
		if choice == -1 { // all are tested
			fmt.Println("All parameters associated with current architecture have been tested")
			// kill python script
			cmd.Process.Signal(syscall.SIGUSR2)
			return 0
		}
	}
	
	savedStatedictFilename := results[choice].StateDictFilename
	savedStatedictFilename = ".nmb/" + savedStatedictFilename

	interactWriter.WriteString(savedStatedictFilename) // send the file name to python
	interactWriter.Close()

	// fill out the received test result, if any
	buf = bytes.NewBuffer(nil)
	_, err = io.Copy(buf, testResultReader)
	utils.Check(err)
	testResultJSON := buf.String()

	fmt.Println("Received: ", testResultJSON)
	if testResultJSON == "" {
		fmt.Println("I bet you forget to put 'numb_test_result' at the end of your python script")
		fmt.Println("It is needed to collect testing result")
		fmt.Println("Put it here and re-test.")
		return 0
	}
	
	_, err = collection.UpdateAll(bson.M{
		"concrete": results[choice].ConcreteGraph, 
		"params": results[choice].Params,
	}, bson.M {
		"$set": bson.M{
			"test": testResultJSON,
		},
	})
	utils.Check(err)

	utils.Check(cmd.Wait())
	return 1
}

// run returns the number of tasks executed
func run(cmdline string, newEnv map[string]string, runconfig map[string]interface{}, mode RunMode, collection *mgo.Collection, queueData string, reader io.Reader) int {
	cmdPath := strings.Split(cmdline, " ")
	cmd := exec.Command(cmdPath[0], cmdPath[1:]...)

	// set runtime config
	var silent = false
	if s1, keyok := runconfig["silent"]; keyok {
		if s2, typeok := s1.(bool); typeok {
			silent = s2
		}
	}
	if !silent {
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
	}
	// end: set runtime config

	oldEnv := os.Environ()
	strNewEnv := utils.Map2env(newEnv)
	env := append(oldEnv, strNewEnv...)
	cmd.Env = env

	// create pipes
	pGraphR, pGraphW, err := os.Pipe()
	utils.Check(err)
	defer pGraphR.Close()

	pParamR, pParamW, err := os.Pipe()
	utils.Check(err)
	defer pParamR.Close()

	pStateR, pStateW, err := os.Pipe()
	utils.Check(err)
	defer pStateR.Close()

	pInteractR, pInteractW, err := os.Pipe() // This is a writing pipe!
	utils.Check(err)
	defer pInteractW.Close()

	pCodeR, pCodeW, err := os.Pipe()
	utils.Check(err)
	defer pCodeR.Close()

	pTestResultR, pTestResultW, err := os.Pipe()
	utils.Check(err)
	defer pTestResultR.Close()

	// end: create pipes

	// setting pipes in py script
	cmd.ExtraFiles = []*os.File{
		pGraphW,
		pParamW,
		pStateW,
		pInteractR, // will block python execution;
		// In python script a signal will be sent to the parent before blocking
		pCodeW,
		pTestResultW,
	}

	// append queue-related pipe if needed.
	var pReceiveParamR *os.File
	if mode == QUEUE {
		pReceiveParamR, pReceiveParamW, err := os.Pipe()
		utils.Check(err)
		cmd.ExtraFiles = append(cmd.ExtraFiles, pReceiveParamR)
		pReceiveParamW.WriteString(queueData)
		pReceiveParamW.Close()
	}

	sigusr1Received := make(chan int)
	if mode == TEST {
		sigs := make(chan os.Signal)
		signal.Notify(sigs, syscall.SIGUSR1)
		go func() {
			<-sigs
			sigusr1Received <- 0
		}()
	}

	utils.Check(cmd.Start())

	// close unused end
	pGraphW.Close()
	pParamW.Close()
	pStateW.Close()
	pInteractR.Close()
	pCodeW.Close()
	pTestResultW.Close()
	if pReceiveParamR != nil {
		pReceiveParamR.Close()
	}

	if reader != nil {
		cmd.Stdin = reader // inject stdin
	}

	if mode == TEST {
		testAll, ok := runconfig["all"].(bool)
		return runTest(cmd, pGraphR, pInteractW, pTestResultR, sigusr1Received, collection, testAll && ok)
	} else {
		return runTrain(cmd, pGraphR, pParamR, pStateR, pCodeR, collection, mode == QUEUE)
	}

}
