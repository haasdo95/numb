// Package analysis provides the functionality to do numb list and numb insight
package analysis

import (
	"strconv"
	"fmt"
	"github.com/olekukonko/tablewriter"
	"sort"
	"os"
	"github.com/nasyxx/numb/database"
	"github.com/nasyxx/numb/utils"
	pp "github.com/nasyxx/numb/prettyprint"
	"gopkg.in/mgo.v2/bson"
	"gopkg.in/mgo.v2"
)

const (
	// BOTH mode lists both tested and untested
	BOTH ListMode = iota
	// TESTED mode lists only tested model
	TESTED
	// SHORT mode lists 5 at most
	SHORT
	// REVERSE mode puts the oldest first
	REVERSE
)
type ListMode int
type ListModes []ListMode

type GroupedEntries struct {
	GroupKey string	`bson:"_id" json:"_id"`
	Entries []database.Schema `bson:"entries" json:"entries"`
	MaxTime int64 `bson:"timestamp" json:"timestamp"`
}

func (modes ListModes) containMode(mode ListMode) bool {
	for _, currMode := range modes {
		if currMode == mode {
			return true
		}
	}
	return false
}

// List lists the models based on the mode given
func List(collection *mgo.Collection, modes ...ListMode)  {
	// process options
	var modesList ListModes = modes
	var isRev = modesList.containMode(REVERSE)
	scope := bson.M{}
	if modesList.containMode(TESTED) {
		scope = bson.M{"test": bson.M{"$ne": ""}}
	}
	// stopAtFive := modesList.containMode(SHORT)

	pipeline := []bson.M {
		bson.M {
			"$match": scope,
		},
		bson.M {
			"$group": bson.M {
				"_id": "$concrete", // group by concrete comp graph
				"entries": bson.M {
					"$push": "$$ROOT",
				},
				"timestamp": bson.M {
					"$max": "$timestamp",
				},
			},
		},
	}
	pipe := collection.Pipe(pipeline)
	results := make([]GroupedEntries, 0)
	pipe.All(&results)
	// sort results by max time
	sort.Slice(results, func (i, j int) bool {
		if isRev {
			return results[i].MaxTime < results[j].MaxTime
		}
		return results[i].MaxTime > results[j].MaxTime
	})
	for _, result := range results {
		// pretty print code
		code := result.Entries[0].Code
		shellWidth := 110
		table := tablewriter.NewWriter(os.Stdout)
		table.SetHeader([]string{"This architecture is generated by the following code:"})
		table.SetAutoWrapText(true)
		table.SetColWidth(shellWidth)
		table.SetAlignment(tablewriter.ALIGN_CENTER)
		table.SetHeaderColor([]int{tablewriter.BgGreenColor, tablewriter.FgBlackColor})
		table.Render()
		fmt.Println(code)
		// sort entries by timestamp
		entries := result.Entries
		sort.Slice(entries, func (i, j int) bool {
			if isRev {
				return entries[i].Timestamp < entries[j].Timestamp
			}
			return entries[i].Timestamp > entries[j].Timestamp
		})
		// iter through schemas(corresponding to different hypermeters used)
		for _, schema := range entries {
			// print id
			fmt.Println("------ID: ", strconv.FormatInt(schema.Timestamp, 10), "------")
			// pretty print params
			obj, err := utils.Str2Obj(schema.Params)
			if schema.Params != "" && err == nil && obj != nil {
				table = pp.TablePrint(obj, tablewriter.BgBlueColor)
				table.Render()
			} else {
				pp.DisplayHyperParamFailure()
			}

			obj, err = utils.Str2Obj(schema.Test)
			if schema.Test != "" && err == nil && obj != nil {
				table = pp.TablePrint(obj, tablewriter.BgYellowColor)
				table.Render()
			} else {
				pp.DisplayTestFailure()
			}
		}
	}
}
